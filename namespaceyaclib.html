<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YACLib: yaclib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YACLib
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ library for concurrent tasks execution</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceyaclib.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">yaclib Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceyaclib_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1Future.html">Future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a mechanism to access the result of async operations.  <a href="classyaclib_1_1Future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a mechanism to access the result of async operations.  <a href="classyaclib_1_1FutureBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1FutureOn.html">FutureOn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a mechanism to access the result of async operations.  <a href="classyaclib_1_1FutureOn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IFunc.html">IFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable interface.  <a href="classyaclib_1_1IFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A intrusive pointer to objects with an embedded reference count.  <a href="classyaclib_1_1IntrusivePtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IRef.html">IRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting interface.  <a href="classyaclib_1_1IRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IThread.html">IThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for thread-pool-like executors.  <a href="classyaclib_1_1IThreadPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1Job.html">Job</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable that can be executed in an <a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a>.  <a href="classyaclib_1_1Job.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaclib_1_1NoRefTag.html">NoRefTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1Promise.html">Promise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1Result.html">Result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulated return value from caller.  <a href="classyaclib_1_1Result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaclib_1_1ResultEmpty.html">ResultEmpty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1ResultError.html">ResultError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaclib_1_1StopError.html">StopError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default error.  <a href="structyaclib_1_1StopError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaclib_1_1StopTag.html">StopTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaclib_1_1Unit.html">Unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal instead of void usage.  <a href="structyaclib_1_1Unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1WaitGroup.html">WaitGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that allows you to Add some amount of async operations and then Wait for it to be Done.  <a href="classyaclib_1_1WaitGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac7d7025bade30573019dc58b09e29fd0"><td class="memTemplParams" colspan="2">template&lt;typename V , typename E &gt; </td></tr>
<tr class="memitem:ac7d7025bade30573019dc58b09e29fd0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0">Contract</a> = std::pair&lt; <a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt;, <a class="el" href="classyaclib_1_1Promise.html">Promise</a>&lt; V, E &gt; &gt;</td></tr>
<tr class="memdesc:ac7d7025bade30573019dc58b09e29fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes channel with future and promise.  <a href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0">More...</a><br /></td></tr>
<tr class="separator:ac7d7025bade30573019dc58b09e29fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb00951a7b082d1c3069a02f12713018"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> = <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; <a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &gt;</td></tr>
<tr class="separator:aeb00951a7b082d1c3069a02f12713018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19c41352ffc16128cc00318a4f8615c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> = <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; <a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a> &gt;</td></tr>
<tr class="separator:ae19c41352ffc16128cc00318a4f8615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab039debaa8307cdefe0c03481b1bf3da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab039debaa8307cdefe0c03481b1bf3da">IThreadPoolPtr</a> = <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; <a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a> &gt;</td></tr>
<tr class="separator:ab039debaa8307cdefe0c03481b1bf3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f01e961fd6af87d533ea57d67d9f1f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">LogCallback</a> = void(*)(std::string_view file, std::size_t line, std::string_view function, std::string_view condition, std::string_view message)</td></tr>
<tr class="separator:aa0f01e961fd6af87d533ea57d67d9f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4f817f4403d420b1975cce677577c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a> = <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; <a class="el" href="classyaclib_1_1IFunc.html">IFunc</a> &gt;</td></tr>
<tr class="separator:acc4f817f4403d420b1975cce677577c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23af97c15e210af60f48dba5fa3736b7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a23af97c15e210af60f48dba5fa3736b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a23af97c15e210af60f48dba5fa3736b7">head_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1Head.html">detail::Head</a>&lt; Args... &gt;::Type</td></tr>
<tr class="separator:a23af97c15e210af60f48dba5fa3736b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad095c23be5e1e565a3698573fc7e0bff"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename... Arg&gt; </td></tr>
<tr class="memitem:ad095c23be5e1e565a3698573fc7e0bff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ad095c23be5e1e565a3698573fc7e0bff">invoke_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1Invoke.html">detail::Invoke</a>&lt; Func, Arg... &gt;::Type</td></tr>
<tr class="separator:ad095c23be5e1e565a3698573fc7e0bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8180a184a21b384fe5c6c35eb5bb9f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc8180a184a21b384fe5c6c35eb5bb9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#adc8180a184a21b384fe5c6c35eb5bb9f">result_value_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt; <a class="el" href="classyaclib_1_1Result.html">Result</a>, T &gt;::Value</td></tr>
<tr class="separator:adc8180a184a21b384fe5c6c35eb5bb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47bee250bfd56f471dc072f0f5be0fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae47bee250bfd56f471dc072f0f5be0fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ae47bee250bfd56f471dc072f0f5be0fc">result_error_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt; <a class="el" href="classyaclib_1_1Result.html">Result</a>, T &gt;::Error</td></tr>
<tr class="separator:ae47bee250bfd56f471dc072f0f5be0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b754febece6ac1cba10b1d43a198dfe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b754febece6ac1cba10b1d43a198dfe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a0b754febece6ac1cba10b1d43a198dfe">future_base_value_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1FutureBaseTypes.html">detail::FutureBaseTypes</a>&lt; T &gt;::Value</td></tr>
<tr class="separator:a0b754febece6ac1cba10b1d43a198dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9982af18a5531817f5879e851fd34601"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9982af18a5531817f5879e851fd34601"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a9982af18a5531817f5879e851fd34601">future_base_error_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1FutureBaseTypes.html">detail::FutureBaseTypes</a>&lt; T &gt;::Error</td></tr>
<tr class="separator:a9982af18a5531817f5879e851fd34601"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a301c7b0024b604dfa0baff5e62df600b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> : char { <a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600ba6adf97f83acf6453d4a6a4b1070f3754">None</a> = 0
, <a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600ba1a5d257dfef0fee3c8b56cdcc2de854b">FirstFail</a> = 1
, <a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600ba390c1dbd73f79789d71c350562508932">LastFail</a> = 2
 }</td></tr>
<tr class="memdesc:a301c7b0024b604dfa0baff5e62df600b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Policy describe how When* algorithm interpret if Future will be fulfilled by error or exception.  <a href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">More...</a><br /></td></tr>
<tr class="separator:a301c7b0024b604dfa0baff5e62df600b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931c767f78cbcd6634cbedbddf405017"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017">ResultState</a> : char { <a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017a689202409e48743b914713f96d93947c">Value</a> = 0
, <a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017ab0d4998a26f5b5742ad38c4af8817e32">Exception</a> = 1
, <a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017a902b0d55fddef6f8d651fe1035b7d4bd">Error</a> = 2
, <a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017ace2c8aed9c2fa0cfbed56cbda4d8bf07">Empty</a> = 3
 }</td></tr>
<tr class="separator:a931c767f78cbcd6634cbedbddf405017"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae5438743a6e37c56005375a161371077"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::DefaultEvent, typename... V, typename... E&gt; </td></tr>
<tr class="memitem:ae5438743a6e37c56005375a161371077"><td class="memTemplItemLeft" align="right" valign="top">YACLIB_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ae5438743a6e37c56005375a161371077">Wait</a> (<a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;... fs)</td></tr>
<tr class="memdesc:ae5438743a6e37c56005375a161371077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until Ready becomes true.  <a href="namespaceyaclib.html#ae5438743a6e37c56005375a161371077">More...</a><br /></td></tr>
<tr class="separator:ae5438743a6e37c56005375a161371077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac43d7da2dbbb9a78471db09f0763c58"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::DefaultEvent, typename It &gt; </td></tr>
<tr class="memitem:aac43d7da2dbbb9a78471db09f0763c58"><td class="memTemplItemLeft" align="right" valign="top">YACLIB_INLINE std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#a94898f412ae94b871897f8e36f8e3dfd">is_future_base_v</a>&lt; It &gt;, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aac43d7da2dbbb9a78471db09f0763c58">Wait</a> (It begin, It end)</td></tr>
<tr class="memdesc:aac43d7da2dbbb9a78471db09f0763c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until Ready becomes true.  <a href="namespaceyaclib.html#aac43d7da2dbbb9a78471db09f0763c58">More...</a><br /></td></tr>
<tr class="separator:aac43d7da2dbbb9a78471db09f0763c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23210d29cc6c824906f9462f648726ed"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::DefaultEvent, typename It &gt; </td></tr>
<tr class="memitem:a23210d29cc6c824906f9462f648726ed"><td class="memTemplItemLeft" align="right" valign="top">YACLIB_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a23210d29cc6c824906f9462f648726ed">Wait</a> (It begin, std::size_t count)</td></tr>
<tr class="memdesc:a23210d29cc6c824906f9462f648726ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until Ready becomes true.  <a href="namespaceyaclib.html#a23210d29cc6c824906f9462f648726ed">More...</a><br /></td></tr>
<tr class="separator:a23210d29cc6c824906f9462f648726ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf08f280db93b1118870ab362bcde335"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename... V, typename... E&gt; </td></tr>
<tr class="memitem:aaf08f280db93b1118870ab362bcde335"><td class="memTemplItemLeft" align="right" valign="top">YACLIB_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aaf08f280db93b1118870ab362bcde335">WaitFor</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout_duration, <a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;... fs)</td></tr>
<tr class="memdesc:aaf08f280db93b1118870ab362bcde335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified timeout duration has elapsed or Ready becomes true.  <a href="namespaceyaclib.html#aaf08f280db93b1118870ab362bcde335">More...</a><br /></td></tr>
<tr class="separator:aaf08f280db93b1118870ab362bcde335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee6378d67d9d7b8e141cd4fd2bea401"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename Iterator &gt; </td></tr>
<tr class="memitem:a7ee6378d67d9d7b8e141cd4fd2bea401"><td class="memTemplItemLeft" align="right" valign="top">YACLIB_INLINE std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#a94898f412ae94b871897f8e36f8e3dfd">is_future_base_v</a>&lt; Iterator &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a7ee6378d67d9d7b8e141cd4fd2bea401">WaitFor</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout_duration, Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a7ee6378d67d9d7b8e141cd4fd2bea401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified timeout duration has elapsed or Ready becomes true.  <a href="namespaceyaclib.html#a7ee6378d67d9d7b8e141cd4fd2bea401">More...</a><br /></td></tr>
<tr class="separator:a7ee6378d67d9d7b8e141cd4fd2bea401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796e0128328cc5d7112b77af2f6b7c53"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename Iterator &gt; </td></tr>
<tr class="memitem:a796e0128328cc5d7112b77af2f6b7c53"><td class="memTemplItemLeft" align="right" valign="top">YACLIB_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a796e0128328cc5d7112b77af2f6b7c53">WaitFor</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout_duration, Iterator begin, std::size_t count)</td></tr>
<tr class="memdesc:a796e0128328cc5d7112b77af2f6b7c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified timeout duration has elapsed or Ready becomes true.  <a href="namespaceyaclib.html#a796e0128328cc5d7112b77af2f6b7c53">More...</a><br /></td></tr>
<tr class="separator:a796e0128328cc5d7112b77af2f6b7c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86c80b56edf9e77a4600f4c4f34d82e"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename... V, typename... E&gt; </td></tr>
<tr class="memitem:ae86c80b56edf9e77a4600f4c4f34d82e"><td class="memTemplItemLeft" align="right" valign="top">YACLIB_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ae86c80b56edf9e77a4600f4c4f34d82e">WaitUntil</a> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout_time, <a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;... fs)</td></tr>
<tr class="memdesc:ae86c80b56edf9e77a4600f4c4f34d82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until specified time has been reached or Ready becomes true.  <a href="namespaceyaclib.html#ae86c80b56edf9e77a4600f4c4f34d82e">More...</a><br /></td></tr>
<tr class="separator:ae86c80b56edf9e77a4600f4c4f34d82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58361dfec531ba37119a5b2ae433c80"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename Iterator &gt; </td></tr>
<tr class="memitem:ad58361dfec531ba37119a5b2ae433c80"><td class="memTemplItemLeft" align="right" valign="top">YACLIB_INLINE std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#a94898f412ae94b871897f8e36f8e3dfd">is_future_base_v</a>&lt; Iterator &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ad58361dfec531ba37119a5b2ae433c80">WaitUntil</a> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout_time, Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:ad58361dfec531ba37119a5b2ae433c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until specified time has been reached or Ready becomes true.  <a href="namespaceyaclib.html#ad58361dfec531ba37119a5b2ae433c80">More...</a><br /></td></tr>
<tr class="separator:ad58361dfec531ba37119a5b2ae433c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab43938dc6b5f4e2366693fc724688dd"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename Iterator &gt; </td></tr>
<tr class="memitem:aab43938dc6b5f4e2366693fc724688dd"><td class="memTemplItemLeft" align="right" valign="top">YACLIB_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aab43938dc6b5f4e2366693fc724688dd">WaitUntil</a> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout_time, Iterator begin, std::size_t count)</td></tr>
<tr class="memdesc:aab43938dc6b5f4e2366693fc724688dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until specified time has been reached or Ready becomes true.  <a href="namespaceyaclib.html#aab43938dc6b5f4e2366693fc724688dd">More...</a><br /></td></tr>
<tr class="separator:aab43938dc6b5f4e2366693fc724688dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049387f05e22db54fadbdac6edfc4218"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::FirstFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </td></tr>
<tr class="memitem:a049387f05e22db54fadbdac6edfc4218"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a049387f05e22db54fadbdac6edfc4218">WhenAll</a> (It begin, std::size_t count)</td></tr>
<tr class="memdesc:a049387f05e22db54fadbdac6edfc4218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready.  <a href="namespaceyaclib.html#a049387f05e22db54fadbdac6edfc4218">More...</a><br /></td></tr>
<tr class="separator:a049387f05e22db54fadbdac6edfc4218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e203f5b4fa643a6e918dc56cfeb5cc8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::FirstFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </td></tr>
<tr class="memitem:a4e203f5b4fa643a6e918dc56cfeb5cc8"><td class="memTemplItemLeft" align="right" valign="top">YACLIB_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a4e203f5b4fa643a6e918dc56cfeb5cc8">WhenAll</a> (It begin, It end)</td></tr>
<tr class="memdesc:a4e203f5b4fa643a6e918dc56cfeb5cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready.  <a href="namespaceyaclib.html#a4e203f5b4fa643a6e918dc56cfeb5cc8">More...</a><br /></td></tr>
<tr class="separator:a4e203f5b4fa643a6e918dc56cfeb5cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab783f07f4f6c76320de23d0dd0b1da79"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::FirstFail, typename E , typename... V&gt; </td></tr>
<tr class="memitem:ab783f07f4f6c76320de23d0dd0b1da79"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab783f07f4f6c76320de23d0dd0b1da79">WhenAll</a> (<a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;&amp;... futures)</td></tr>
<tr class="memdesc:ab783f07f4f6c76320de23d0dd0b1da79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready.  <a href="namespaceyaclib.html#ab783f07f4f6c76320de23d0dd0b1da79">More...</a><br /></td></tr>
<tr class="separator:ab783f07f4f6c76320de23d0dd0b1da79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcdf1285386bdb56057aca0a41fd124"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::LastFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </td></tr>
<tr class="memitem:acbcdf1285386bdb56057aca0a41fd124"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#acbcdf1285386bdb56057aca0a41fd124">WhenAny</a> (It begin, std::size_t count)</td></tr>
<tr class="memdesc:acbcdf1285386bdb56057aca0a41fd124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready.  <a href="namespaceyaclib.html#acbcdf1285386bdb56057aca0a41fd124">More...</a><br /></td></tr>
<tr class="separator:acbcdf1285386bdb56057aca0a41fd124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fa2a377ea08ee84f27e8ef086b90db"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::LastFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </td></tr>
<tr class="memitem:a68fa2a377ea08ee84f27e8ef086b90db"><td class="memTemplItemLeft" align="right" valign="top">YACLIB_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a68fa2a377ea08ee84f27e8ef086b90db">WhenAny</a> (It begin, It end)</td></tr>
<tr class="memdesc:a68fa2a377ea08ee84f27e8ef086b90db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready.  <a href="namespaceyaclib.html#a68fa2a377ea08ee84f27e8ef086b90db">More...</a><br /></td></tr>
<tr class="separator:a68fa2a377ea08ee84f27e8ef086b90db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddea8e34f0fc25462c13775709fc6fe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::LastFail, typename E , typename... V&gt; </td></tr>
<tr class="memitem:abddea8e34f0fc25462c13775709fc6fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#abddea8e34f0fc25462c13775709fc6fe">WhenAny</a> (<a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;&amp;... futures)</td></tr>
<tr class="memdesc:abddea8e34f0fc25462c13775709fc6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready.  <a href="namespaceyaclib.html#abddea8e34f0fc25462c13775709fc6fe">More...</a><br /></td></tr>
<tr class="separator:abddea8e34f0fc25462c13775709fc6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac918e7a0c384bcf611e0b5b4b2cd5504"><td class="memTemplParams" colspan="2">template&lt;typename V  = void, typename E  = StopError&gt; </td></tr>
<tr class="memitem:ac918e7a0c384bcf611e0b5b4b2cd5504"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0">Contract</a>&lt; V, E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ac918e7a0c384bcf611e0b5b4b2cd5504">MakeContract</a> ()</td></tr>
<tr class="memdesc:ac918e7a0c384bcf611e0b5b4b2cd5504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates related future and promise.  <a href="namespaceyaclib.html#ac918e7a0c384bcf611e0b5b4b2cd5504">More...</a><br /></td></tr>
<tr class="separator:ac918e7a0c384bcf611e0b5b4b2cd5504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf4462ab5b93960f89cee782fdb67a5"><td class="memTemplParams" colspan="2">template&lt;typename V  = Unit, typename E  = StopError, typename... Args&gt; </td></tr>
<tr class="memitem:abaf4462ab5b93960f89cee782fdb67a5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#abaf4462ab5b93960f89cee782fdb67a5">MakeFuture</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abaf4462ab5b93960f89cee782fdb67a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for create Ready <a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a>.  <a href="namespaceyaclib.html#abaf4462ab5b93960f89cee782fdb67a5">More...</a><br /></td></tr>
<tr class="separator:abaf4462ab5b93960f89cee782fdb67a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910661586b10c7244825a8f94e188500"><td class="memTemplParams" colspan="2">template&lt;typename E  = StopError, typename Func &gt; </td></tr>
<tr class="memitem:a910661586b10c7244825a8f94e188500"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a910661586b10c7244825a8f94e188500">Run</a> (<a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp;e, Func &amp;&amp;f)</td></tr>
<tr class="memdesc:a910661586b10c7244825a8f94e188500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute Callable func on executor.  <a href="namespaceyaclib.html#a910661586b10c7244825a8f94e188500">More...</a><br /></td></tr>
<tr class="separator:a910661586b10c7244825a8f94e188500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780473bb4ff3e892c33ff3e6b2a5401f"><td class="memTemplParams" colspan="2">template&lt;typename... V, typename... E&gt; </td></tr>
<tr class="memitem:a780473bb4ff3e892c33ff3e6b2a5401f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1detail_1_1AwaitAwaiter.html">detail::AwaitAwaiter</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a780473bb4ff3e892c33ff3e6b2a5401f">Await</a> (<a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;... fs)</td></tr>
<tr class="memdesc:a780473bb4ff3e892c33ff3e6b2a5401f"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO(mkornaukhov03) Add doxygen docs.  <a href="namespaceyaclib.html#a780473bb4ff3e892c33ff3e6b2a5401f">More...</a><br /></td></tr>
<tr class="separator:a780473bb4ff3e892c33ff3e6b2a5401f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc543f55731193eefe9c994eeec8ff76"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:afc543f55731193eefe9c994eeec8ff76"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#a94898f412ae94b871897f8e36f8e3dfd">is_future_base_v</a>&lt; Iterator &gt;, <a class="el" href="classyaclib_1_1detail_1_1AwaitAwaiter.html">detail::AwaitAwaiter</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#afc543f55731193eefe9c994eeec8ff76">Await</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:afc543f55731193eefe9c994eeec8ff76"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO(mkornaukhov03) Add doxygen docs.  <a href="namespaceyaclib.html#afc543f55731193eefe9c994eeec8ff76">More...</a><br /></td></tr>
<tr class="separator:afc543f55731193eefe9c994eeec8ff76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf83236a05a886e8fe33b155d331868"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:afbf83236a05a886e8fe33b155d331868"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#a94898f412ae94b871897f8e36f8e3dfd">is_future_base_v</a>&lt; Iterator &gt;, <a class="el" href="classyaclib_1_1detail_1_1AwaitAwaiter.html">detail::AwaitAwaiter</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#afbf83236a05a886e8fe33b155d331868">Await</a> (Iterator begin, std::size_t count)</td></tr>
<tr class="memdesc:afbf83236a05a886e8fe33b155d331868"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO(mkornaukhov03) Add doxygen docs.  <a href="namespaceyaclib.html#afbf83236a05a886e8fe33b155d331868">More...</a><br /></td></tr>
<tr class="separator:afbf83236a05a886e8fe33b155d331868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade53700d8fafbc716f9ff592aafbfcfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1detail_1_1OnAwaiter.html">detail::OnAwaiter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ade53700d8fafbc716f9ff592aafbfcfa">On</a> (<a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp;e)</td></tr>
<tr class="memdesc:ade53700d8fafbc716f9ff592aafbfcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO(mkornaukhov03) Add doxygen docs.  <a href="namespaceyaclib.html#ade53700d8fafbc716f9ff592aafbfcfa">More...</a><br /></td></tr>
<tr class="separator:ade53700d8fafbc716f9ff592aafbfcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8af5a9e84597d87efe863329f4324fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aa8af5a9e84597d87efe863329f4324fc">MakeInline</a> () noexcept</td></tr>
<tr class="memdesc:aa8af5a9e84597d87efe863329f4324fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Inline executor singleton object.  <a href="namespaceyaclib.html#aa8af5a9e84597d87efe863329f4324fc">More...</a><br /></td></tr>
<tr class="separator:aa8af5a9e84597d87efe863329f4324fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7d050cd191bf12f4b29b3f97050c83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a7f7d050cd191bf12f4b29b3f97050c83">MakeStrand</a> (<a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> e)</td></tr>
<tr class="memdesc:a7f7d050cd191bf12f4b29b3f97050c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strand is the asynchronous analogue of a mutex.  <a href="namespaceyaclib.html#a7f7d050cd191bf12f4b29b3f97050c83">More...</a><br /></td></tr>
<tr class="separator:a7f7d050cd191bf12f4b29b3f97050c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0acaa9b89820432d210ddcc71cb42e"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a1c0acaa9b89820432d210ddcc71cb42e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a1c0acaa9b89820432d210ddcc71cb42e">Submit</a> (<a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp;executor, Func &amp;&amp;f)</td></tr>
<tr class="memdesc:a1c0acaa9b89820432d210ddcc71cb42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit given func for details.  <a href="namespaceyaclib.html#a1c0acaa9b89820432d210ddcc71cb42e">More...</a><br /></td></tr>
<tr class="separator:a1c0acaa9b89820432d210ddcc71cb42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6470522549981a792f7a073772ff9c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a6470522549981a792f7a073772ff9c57">MakeThreadFactory</a> (std::size_t cache=0)</td></tr>
<tr class="separator:a6470522549981a792f7a073772ff9c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba22a625dc73cea7f6310d6e6147aa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a0ba22a625dc73cea7f6310d6e6147aa3">MakeThreadFactory</a> (<a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> base, std::string_view name)</td></tr>
<tr class="separator:a0ba22a625dc73cea7f6310d6e6147aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58431cd89c902b17a1f386e2be4f4d33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a58431cd89c902b17a1f386e2be4f4d33">MakeThreadFactory</a> (<a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> base, std::size_t priority)</td></tr>
<tr class="separator:a58431cd89c902b17a1f386e2be4f4d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3348b06a8925f35eb031e9563b1980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a3a3348b06a8925f35eb031e9563b1980">MakeThreadFactory</a> (<a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> base, <a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a> acquire, <a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a> release)</td></tr>
<tr class="separator:a3a3348b06a8925f35eb031e9563b1980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3681d83edb8b4ed32fc838e421ff5491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a3681d83edb8b4ed32fc838e421ff5491">CurrentThreadPool</a> () noexcept</td></tr>
<tr class="separator:a3681d83edb8b4ed32fc838e421ff5491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a1d3907ba9fca05451fca30c8d9b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ad7a1d3907ba9fca05451fca30c8d9b96">SetCurrentThreadPool</a> (<a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp;executor) noexcept</td></tr>
<tr class="separator:ad7a1d3907ba9fca05451fca30c8d9b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd02a3297ea3c5b6de6144c3b993d6f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ab039debaa8307cdefe0c03481b1bf3da">IThreadPoolPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#abd02a3297ea3c5b6de6144c3b993d6f6">MakeThreadPool</a> (std::size_t threads=std::thread::hardware_concurrency(), <a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> tf=<a class="el" href="namespaceyaclib.html#a6470522549981a792f7a073772ff9c57">MakeThreadFactory</a>())</td></tr>
<tr class="memdesc:abd02a3297ea3c5b6de6144c3b993d6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new ThreadPool object.  <a href="namespaceyaclib.html#abd02a3297ea3c5b6de6144c3b993d6f6">More...</a><br /></td></tr>
<tr class="separator:abd02a3297ea3c5b6de6144c3b993d6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7204a0d02995092530f470272dd603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a0d7204a0d02995092530f470272dd603">SetFaultFrequency</a> (std::uint32_t freq)</td></tr>
<tr class="memdesc:a0d7204a0d02995092530f470272dd603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets frequency with which fault will be injected.  <a href="namespaceyaclib.html#a0d7204a0d02995092530f470272dd603">More...</a><br /></td></tr>
<tr class="separator:a0d7204a0d02995092530f470272dd603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78212c27ad6642817def05396421867b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a78212c27ad6642817def05396421867b">SetFaultSleepTime</a> (std::uint32_t ns)</td></tr>
<tr class="memdesc:a78212c27ad6642817def05396421867b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets sleep time if sleep is used instead of yield for interrupting thread execution for fault injection.  <a href="namespaceyaclib.html#a78212c27ad6642817def05396421867b">More...</a><br /></td></tr>
<tr class="separator:a78212c27ad6642817def05396421867b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128d0cc1b7e4a609d69e5a8e7a160fc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1detail_1_1Injector.html">detail::Injector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a128d0cc1b7e4a609d69e5a8e7a160fc6">GetInjector</a> () noexcept</td></tr>
<tr class="separator:a128d0cc1b7e4a609d69e5a8e7a160fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f41f976471fc0052e78ccc173600f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a6f41f976471fc0052e78ccc173600f68">InjectFault</a> () noexcept</td></tr>
<tr class="separator:a6f41f976471fc0052e78ccc173600f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581f4596db9c1cb39aff3ff0c21901f7"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a581f4596db9c1cb39aff3ff0c21901f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a581f4596db9c1cb39aff3ff0c21901f7">MakeFunc</a> (Func &amp;&amp;f)</td></tr>
<tr class="memdesc:a581f4596db9c1cb39aff3ff0c21901f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create shared <a class="el" href="classyaclib_1_1IFunc.html">IFunc</a> object from any Callable func.  <a href="namespaceyaclib.html#a581f4596db9c1cb39aff3ff0c21901f7">More...</a><br /></td></tr>
<tr class="separator:a581f4596db9c1cb39aff3ff0c21901f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacae80b7f02ca84047a9a5564af8a869"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , typename PtrType  = ObjectType, typename... Args&gt; </td></tr>
<tr class="memitem:aacae80b7f02ca84047a9a5564af8a869"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; PtrType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aacae80b7f02ca84047a9a5564af8a869">MakeIntrusive</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:aacae80b7f02ca84047a9a5564af8a869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f58c88424862c7970f5e34368691501"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7f58c88424862c7970f5e34368691501"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a7f58c88424862c7970f5e34368691501">operator==</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7f58c88424862c7970f5e34368691501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab205ab99a80599cf567522997ba91b7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab205ab99a80599cf567522997ba91b7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab205ab99a80599cf567522997ba91b7b">operator!=</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab205ab99a80599cf567522997ba91b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5c2b342ea0d8dcc08d36a688e4002"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aadf5c2b342ea0d8dcc08d36a688e4002"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aadf5c2b342ea0d8dcc08d36a688e4002">operator==</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, U *rhs) noexcept</td></tr>
<tr class="separator:aadf5c2b342ea0d8dcc08d36a688e4002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad623d6b5af5166e2129c5e7c524ac7a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad623d6b5af5166e2129c5e7c524ac7a8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ad623d6b5af5166e2129c5e7c524ac7a8">operator!=</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, U *rhs) noexcept</td></tr>
<tr class="separator:ad623d6b5af5166e2129c5e7c524ac7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a93f75dbd32dff52a60d524c1a96db"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a06a93f75dbd32dff52a60d524c1a96db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a06a93f75dbd32dff52a60d524c1a96db">operator==</a> (T *lhs, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a06a93f75dbd32dff52a60d524c1a96db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e502d06dc99e7d95a4b94cf92c0e7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa3e502d06dc99e7d95a4b94cf92c0e7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aa3e502d06dc99e7d95a4b94cf92c0e7b">operator!=</a> (T *lhs, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa3e502d06dc99e7d95a4b94cf92c0e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6c964d5e75d8d4f77e77367eda447f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff6c964d5e75d8d4f77e77367eda447f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aff6c964d5e75d8d4f77e77367eda447f">operator==</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:aff6c964d5e75d8d4f77e77367eda447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e76ea36acc0b15ff59f471dde2f1bf6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e76ea36acc0b15ff59f471dde2f1bf6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a7e76ea36acc0b15ff59f471dde2f1bf6">operator==</a> (std::nullptr_t, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7e76ea36acc0b15ff59f471dde2f1bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db9bf2206ad479e4672445453581c4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6db9bf2206ad479e4672445453581c4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a6db9bf2206ad479e4672445453581c4a">operator!=</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a6db9bf2206ad479e4672445453581c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f85de6a478cf2b7036bbaf9b7f5243"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4f85de6a478cf2b7036bbaf9b7f5243"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab4f85de6a478cf2b7036bbaf9b7f5243">operator!=</a> (std::nullptr_t, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab4f85de6a478cf2b7036bbaf9b7f5243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c5d80129106db68da58a29eb4c96fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32c5d80129106db68da58a29eb4c96fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a32c5d80129106db68da58a29eb4c96fa">operator&lt;</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a32c5d80129106db68da58a29eb4c96fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6f076aaf64ec86cd6aef4cef9f80fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba6f076aaf64ec86cd6aef4cef9f80fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aba6f076aaf64ec86cd6aef4cef9f80fa">Check</a> () noexcept</td></tr>
<tr class="separator:aba6f076aaf64ec86cd6aef4cef9f80fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3cc59594eb77f82b357ffd894486c506"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename... Arg&gt; </td></tr>
<tr class="memitem:a3cc59594eb77f82b357ffd894486c506"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a3cc59594eb77f82b357ffd894486c506">is_invocable_v</a> = <a class="el" href="structyaclib_1_1detail_1_1IsInvocable.html">detail::IsInvocable</a>&lt;Func, Arg...&gt;::Value</td></tr>
<tr class="separator:a3cc59594eb77f82b357ffd894486c506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce1ff71818739a9a00c65a185cf64ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ce1ff71818739a9a00c65a185cf64ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a2ce1ff71818739a9a00c65a185cf64ff">is_result_v</a> = <a class="el" href="structyaclib_1_1detail_1_1IsInstantiationOf.html">detail::IsInstantiationOf</a>&lt;<a class="el" href="classyaclib_1_1Result.html">Result</a>, T&gt;::Value</td></tr>
<tr class="separator:a2ce1ff71818739a9a00c65a185cf64ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94898f412ae94b871897f8e36f8e3dfd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94898f412ae94b871897f8e36f8e3dfd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a94898f412ae94b871897f8e36f8e3dfd">is_future_base_v</a></td></tr>
<tr class="separator:a94898f412ae94b871897f8e36f8e3dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac7d7025bade30573019dc58b09e29fd0" name="ac7d7025bade30573019dc58b09e29fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d7025bade30573019dc58b09e29fd0">&#9670;&nbsp;</a></span>Contract</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0">yaclib::Contract</a> = typedef std::pair&lt;<a class="el" href="classyaclib_1_1Future.html">Future</a>&lt;V, E&gt;, <a class="el" href="classyaclib_1_1Promise.html">Promise</a>&lt;V, E&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes channel with future and promise. </p>

<p class="definition">Definition at line <a class="el" href="contract_8hpp_source.html#l00010">10</a> of file <a class="el" href="contract_8hpp_source.html">contract.hpp</a>.</p>

</div>
</div>
<a id="a9982af18a5531817f5879e851fd34601" name="a9982af18a5531817f5879e851fd34601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9982af18a5531817f5879e851fd34601">&#9670;&nbsp;</a></span>future_base_error_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#a9982af18a5531817f5879e851fd34601">yaclib::future_base_error_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1FutureBaseTypes.html">detail::FutureBaseTypes</a>&lt;T&gt;::Error</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00038">38</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a0b754febece6ac1cba10b1d43a198dfe" name="a0b754febece6ac1cba10b1d43a198dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b754febece6ac1cba10b1d43a198dfe">&#9670;&nbsp;</a></span>future_base_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#a0b754febece6ac1cba10b1d43a198dfe">yaclib::future_base_value_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1FutureBaseTypes.html">detail::FutureBaseTypes</a>&lt;T&gt;::Value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00035">35</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a23af97c15e210af60f48dba5fa3736b7" name="a23af97c15e210af60f48dba5fa3736b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23af97c15e210af60f48dba5fa3736b7">&#9670;&nbsp;</a></span>head_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#a23af97c15e210af60f48dba5fa3736b7">yaclib::head_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1Head.html">detail::Head</a>&lt;Args...&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00012">12</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aeb00951a7b082d1c3069a02f12713018" name="aeb00951a7b082d1c3069a02f12713018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb00951a7b082d1c3069a02f12713018">&#9670;&nbsp;</a></span>IExecutorPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">yaclib::IExecutorPtr</a> = typedef <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt;<a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="executor_8hpp_source.html#l00037">37</a> of file <a class="el" href="executor_8hpp_source.html">executor.hpp</a>.</p>

</div>
</div>
<a id="acc4f817f4403d420b1975cce677577c2" name="acc4f817f4403d420b1975cce677577c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4f817f4403d420b1975cce677577c2">&#9670;&nbsp;</a></span>IFuncPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">yaclib::IFuncPtr</a> = typedef <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt;<a class="el" href="classyaclib_1_1IFunc.html">IFunc</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="shared__func_8hpp_source.html#l00028">28</a> of file <a class="el" href="shared__func_8hpp_source.html">shared_func.hpp</a>.</p>

</div>
</div>
<a id="ad095c23be5e1e565a3698573fc7e0bff" name="ad095c23be5e1e565a3698573fc7e0bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad095c23be5e1e565a3698573fc7e0bff">&#9670;&nbsp;</a></span>invoke_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename... Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#ad095c23be5e1e565a3698573fc7e0bff">yaclib::invoke_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1Invoke.html">detail::Invoke</a>&lt;Func, Arg...&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00018">18</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ae19c41352ffc16128cc00318a4f8615c" name="ae19c41352ffc16128cc00318a4f8615c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19c41352ffc16128cc00318a4f8615c">&#9670;&nbsp;</a></span>IThreadFactoryPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">yaclib::IThreadFactoryPtr</a> = typedef <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt;<a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8hpp_source.html#l00023">23</a> of file <a class="el" href="thread__factory_8hpp_source.html">thread_factory.hpp</a>.</p>

</div>
</div>
<a id="ab039debaa8307cdefe0c03481b1bf3da" name="ab039debaa8307cdefe0c03481b1bf3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab039debaa8307cdefe0c03481b1bf3da">&#9670;&nbsp;</a></span>IThreadPoolPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#ab039debaa8307cdefe0c03481b1bf3da">yaclib::IThreadPoolPtr</a> = typedef <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt;<a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00041">41</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="aa0f01e961fd6af87d533ea57d67d9f1f" name="aa0f01e961fd6af87d533ea57d67d9f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f01e961fd6af87d533ea57d67d9f1f">&#9670;&nbsp;</a></span>LogCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">yaclib::LogCallback</a> = typedef void (*)(std::string_view file, std::size_t line, std::string_view function, std::string_view condition, std::string_view message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="log_8hpp_source.html#l00009">9</a> of file <a class="el" href="log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a id="ae47bee250bfd56f471dc072f0f5be0fc" name="ae47bee250bfd56f471dc072f0f5be0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47bee250bfd56f471dc072f0f5be0fc">&#9670;&nbsp;</a></span>result_error_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#ae47bee250bfd56f471dc072f0f5be0fc">yaclib::result_error_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt;<a class="el" href="classyaclib_1_1Result.html">Result</a>, T&gt;::Error</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00027">27</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="adc8180a184a21b384fe5c6c35eb5bb9f" name="adc8180a184a21b384fe5c6c35eb5bb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8180a184a21b384fe5c6c35eb5bb9f">&#9670;&nbsp;</a></span>result_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#adc8180a184a21b384fe5c6c35eb5bb9f">yaclib::result_value_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt;<a class="el" href="classyaclib_1_1Result.html">Result</a>, T&gt;::Value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00024">24</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a931c767f78cbcd6634cbedbddf405017" name="a931c767f78cbcd6634cbedbddf405017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931c767f78cbcd6634cbedbddf405017">&#9670;&nbsp;</a></span>ResultState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017">yaclib::ResultState</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a931c767f78cbcd6634cbedbddf405017a689202409e48743b914713f96d93947c" name="a931c767f78cbcd6634cbedbddf405017a689202409e48743b914713f96d93947c"></a>Value&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a931c767f78cbcd6634cbedbddf405017ab0d4998a26f5b5742ad38c4af8817e32" name="a931c767f78cbcd6634cbedbddf405017ab0d4998a26f5b5742ad38c4af8817e32"></a>Exception&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a931c767f78cbcd6634cbedbddf405017a902b0d55fddef6f8d651fe1035b7d4bd" name="a931c767f78cbcd6634cbedbddf405017a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a931c767f78cbcd6634cbedbddf405017ace2c8aed9c2fa0cfbed56cbda4d8bf07" name="a931c767f78cbcd6634cbedbddf405017ace2c8aed9c2fa0cfbed56cbda4d8bf07"></a>Empty&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="result_8hpp_source.html#l00014">14</a> of file <a class="el" href="result_8hpp_source.html">result.hpp</a>.</p>

</div>
</div>
<a id="a301c7b0024b604dfa0baff5e62df600b" name="a301c7b0024b604dfa0baff5e62df600b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301c7b0024b604dfa0baff5e62df600b">&#9670;&nbsp;</a></span>WhenPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">yaclib::WhenPolicy</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This Policy describe how When* algorithm interpret if <a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a> will be fulfilled by error or exception. </p>
<p >None &ndash; fail same as ok, another words save all fails FirstFail &ndash; save first fail, default for WhenAll LastFail &ndash; save last fail, default for WhenAny </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a301c7b0024b604dfa0baff5e62df600ba6adf97f83acf6453d4a6a4b1070f3754" name="a301c7b0024b604dfa0baff5e62df600ba6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a301c7b0024b604dfa0baff5e62df600ba1a5d257dfef0fee3c8b56cdcc2de854b" name="a301c7b0024b604dfa0baff5e62df600ba1a5d257dfef0fee3c8b56cdcc2de854b"></a>FirstFail&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a301c7b0024b604dfa0baff5e62df600ba390c1dbd73f79789d71c350562508932" name="a301c7b0024b604dfa0baff5e62df600ba390c1dbd73f79789d71c350562508932"></a>LastFail&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="when__policy_8hpp_source.html#l00012">12</a> of file <a class="el" href="when__policy_8hpp_source.html">when_policy.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a780473bb4ff3e892c33ff3e6b2a5401f" name="a780473bb4ff3e892c33ff3e6b2a5401f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780473bb4ff3e892c33ff3e6b2a5401f">&#9670;&nbsp;</a></span>Await() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... V, typename... E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1detail_1_1AwaitAwaiter.html">detail::AwaitAwaiter</a> yaclib::Await </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;...&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO(mkornaukhov03) Add doxygen docs. </p>

<p class="definition">Definition at line <a class="el" href="await_8hpp_source.html#l00015">15</a> of file <a class="el" href="await_8hpp_source.html">await.hpp</a>.</p>

<p class="reference">References <a class="el" href="future__impl_8hpp_source.html#l00103">yaclib::FutureBase&lt; V, E &gt;::GetCore()</a>.</p>

</div>
</div>
<a id="afc543f55731193eefe9c994eeec8ff76" name="afc543f55731193eefe9c994eeec8ff76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc543f55731193eefe9c994eeec8ff76">&#9670;&nbsp;</a></span>Await() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#a94898f412ae94b871897f8e36f8e3dfd">is_future_base_v</a>&lt; Iterator &gt;, <a class="el" href="classyaclib_1_1detail_1_1AwaitAwaiter.html">detail::AwaitAwaiter</a> &gt; yaclib::Await </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO(mkornaukhov03) Add doxygen docs. </p>

<p class="definition">Definition at line <a class="el" href="await_8hpp_source.html#l00023">23</a> of file <a class="el" href="await_8hpp_source.html">await.hpp</a>.</p>

</div>
</div>
<a id="afbf83236a05a886e8fe33b155d331868" name="afbf83236a05a886e8fe33b155d331868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf83236a05a886e8fe33b155d331868">&#9670;&nbsp;</a></span>Await() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#a94898f412ae94b871897f8e36f8e3dfd">is_future_base_v</a>&lt; Iterator &gt;, <a class="el" href="classyaclib_1_1detail_1_1AwaitAwaiter.html">detail::AwaitAwaiter</a> &gt; yaclib::Await </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO(mkornaukhov03) Add doxygen docs. </p>

<p class="definition">Definition at line <a class="el" href="await_8hpp_source.html#l00033">33</a> of file <a class="el" href="await_8hpp_source.html">await.hpp</a>.</p>

</div>
</div>
<a id="aba6f076aaf64ec86cd6aef4cef9f80fa" name="aba6f076aaf64ec86cd6aef4cef9f80fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6f076aaf64ec86cd6aef4cef9f80fa">&#9670;&nbsp;</a></span>Check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool yaclib::Check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00041">41</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a3681d83edb8b4ed32fc838e421ff5491" name="a3681d83edb8b4ed32fc838e421ff5491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3681d83edb8b4ed32fc838e421ff5491">&#9670;&nbsp;</a></span>CurrentThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp; yaclib::CurrentThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Thread local pointer to the ThreadPool that owns the current thread Inline executor if no ThreadPool owns the thread </dd></dl>

<p class="definition">Definition at line <a class="el" href="src_2executor_2thread__pool_8cpp_source.html#l00148">148</a> of file <a class="el" href="src_2executor_2thread__pool_8cpp_source.html">thread_pool.cpp</a>.</p>

</div>
</div>
<a id="a128d0cc1b7e4a609d69e5a8e7a160fc6" name="a128d0cc1b7e4a609d69e5a8e7a160fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128d0cc1b7e4a609d69e5a8e7a160fc6">&#9670;&nbsp;</a></span>GetInjector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1detail_1_1Injector.html">detail::Injector</a> * yaclib::GetInjector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="inject_8cpp_source.html#l00006">6</a> of file <a class="el" href="inject_8cpp_source.html">inject.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="inject_8cpp_source.html#l00011">InjectFault()</a>.</p>

</div>
</div>
<a id="a6f41f976471fc0052e78ccc173600f68" name="a6f41f976471fc0052e78ccc173600f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f41f976471fc0052e78ccc173600f68">&#9670;&nbsp;</a></span>InjectFault()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::InjectFault </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="inject_8cpp_source.html#l00011">11</a> of file <a class="el" href="inject_8cpp_source.html">inject.cpp</a>.</p>

<p class="reference">References <a class="el" href="inject_8cpp_source.html#l00006">GetInjector()</a>, and <a class="el" href="injector_8cpp_source.html#l00017">yaclib::detail::Injector::MaybeInject()</a>.</p>

</div>
</div>
<a id="ac918e7a0c384bcf611e0b5b4b2cd5504" name="ac918e7a0c384bcf611e0b5b4b2cd5504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac918e7a0c384bcf611e0b5b4b2cd5504">&#9670;&nbsp;</a></span>MakeContract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = StopError&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0">Contract</a>&lt; V, E &gt; yaclib::MakeContract </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates related future and promise. </p>
<dl class="section return"><dt>Returns</dt><dd>a </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0" title="Describes channel with future and promise.">Contract</a> object with new future and promise </dd></dl>

<p class="definition">Definition at line <a class="el" href="contract_8hpp_source.html#l00019">19</a> of file <a class="el" href="contract_8hpp_source.html">contract.hpp</a>.</p>

</div>
</div>
<a id="a581f4596db9c1cb39aff3ff0c21901f7" name="a581f4596db9c1cb39aff3ff0c21901f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581f4596db9c1cb39aff3ff0c21901f7">&#9670;&nbsp;</a></span>MakeFunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a> yaclib::MakeFunc </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create shared <a class="el" href="classyaclib_1_1IFunc.html">IFunc</a> object from any Callable func. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Callable object </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="shared__func_8hpp_source.html#l00035">35</a> of file <a class="el" href="shared__func_8hpp_source.html">shared_func.hpp</a>.</p>

</div>
</div>
<a id="abaf4462ab5b93960f89cee782fdb67a5" name="abaf4462ab5b93960f89cee782fdb67a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf4462ab5b93960f89cee782fdb67a5">&#9670;&nbsp;</a></span>MakeFuture()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = Unit, typename E  = StopError, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::MakeFuture </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for create Ready <a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>if not default value, it's type of <a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a> value </td></tr>
    <tr><td class="paramname">E</td><td>type of <a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a> error, by default its </td></tr>
    <tr><td class="paramname">Args</td><td>if single, and V default, then used as type of <a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a> value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>for fulfill <a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ready <a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="future_8hpp_source.html#l00198">198</a> of file <a class="el" href="future_8hpp_source.html">future.hpp</a>.</p>

</div>
</div>
<a id="aa8af5a9e84597d87efe863329f4324fc" name="aa8af5a9e84597d87efe863329f4324fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8af5a9e84597d87efe863329f4324fc">&#9670;&nbsp;</a></span>MakeInline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp; yaclib::MakeInline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Inline executor singleton object. </p>
<p >This executor immediately executes given Callable object in the same OS thread without any overhead. So it always return false from Submit, we only call Call, no submit </p><dl class="section note"><dt>Note</dt><dd>This object is useful as safe default executor value. See example.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> task = [] {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Without inline executor:</span></div>
<div class="line"><a class="code hl_typedef" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> executor = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="keywordflow">if</span> (...) {</div>
<div class="line">  executor = <a class="code hl_function" href="namespaceyaclib.html#abd02a3297ea3c5b6de6144c3b993d6f6">MakeThreadPool</a>(4);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (executor) {</div>
<div class="line">  executor-&gt;Submit(task);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  a();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With inline executor:</span></div>
<div class="line"><a class="code hl_typedef" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> executor = &amp;<a class="code hl_function" href="namespaceyaclib.html#aa8af5a9e84597d87efe863329f4324fc">MakeInline</a>();</div>
<div class="line"><span class="keywordflow">if</span> (...) {</div>
<div class="line">  executor = <a class="code hl_function" href="namespaceyaclib.html#abd02a3297ea3c5b6de6144c3b993d6f6">MakeThreadPool</a>(4);</div>
<div class="line">}</div>
<div class="line">executor-&gt;Submit(task);</div>
<div class="ttc" id="anamespaceyaclib_html_aa8af5a9e84597d87efe863329f4324fc"><div class="ttname"><a href="namespaceyaclib.html#aa8af5a9e84597d87efe863329f4324fc">yaclib::MakeInline</a></div><div class="ttdeci">IExecutor &amp; MakeInline() noexcept</div><div class="ttdoc">Get Inline executor singleton object.</div><div class="ttdef"><b>Definition:</b> <a href="inline_8cpp_source.html#l00024">inline.cpp:24</a></div></div>
<div class="ttc" id="anamespaceyaclib_html_abd02a3297ea3c5b6de6144c3b993d6f6"><div class="ttname"><a href="namespaceyaclib.html#abd02a3297ea3c5b6de6144c3b993d6f6">yaclib::MakeThreadPool</a></div><div class="ttdeci">IThreadPoolPtr MakeThreadPool(std::size_t threads=std::thread::hardware_concurrency(), IThreadFactoryPtr tf=MakeThreadFactory())</div><div class="ttdoc">Create new ThreadPool object.</div><div class="ttdef"><b>Definition:</b> <a href="src_2executor_2thread__pool_8cpp_source.html#l00152">thread_pool.cpp:152</a></div></div>
<div class="ttc" id="anamespaceyaclib_html_aeb00951a7b082d1c3069a02f12713018"><div class="ttname"><a href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">yaclib::IExecutorPtr</a></div><div class="ttdeci">IntrusivePtr&lt; IExecutor &gt; IExecutorPtr</div><div class="ttdef"><b>Definition:</b> <a href="executor_8hpp_source.html#l00037">executor.hpp:37</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="inline_8cpp_source.html#l00024">24</a> of file <a class="el" href="inline_8cpp_source.html">inline.cpp</a>.</p>

<p class="reference">References <a class="el" href="inline_8cpp_source.html#l00020">yaclib::detail::sInline</a>.</p>

</div>
</div>
<a id="aacae80b7f02ca84047a9a5564af8a869" name="aacae80b7f02ca84047a9a5564af8a869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacae80b7f02ca84047a9a5564af8a869">&#9670;&nbsp;</a></span>MakeIntrusive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , typename PtrType  = ObjectType, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; PtrType &gt; yaclib::MakeIntrusive </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00009">9</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="a7f7d050cd191bf12f4b29b3f97050c83" name="a7f7d050cd191bf12f4b29b3f97050c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7d050cd191bf12f4b29b3f97050c83">&#9670;&nbsp;</a></span>MakeStrand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> yaclib::MakeStrand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strand is the asynchronous analogue of a mutex. </p>
<p >It guarantees that the tasks scheduled for it will be executed strictly sequentially. Strand itself does not have its own threads, it decorates another executor and uses it to run its tasks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>executor to decorate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to new Strand instance </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="simple_8cpp-example.html#a12">simple.cpp</a>, and <a class="el" href="strand_8cpp-example.html#a2">strand.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2executor_2strand_8cpp_source.html#l00082">82</a> of file <a class="el" href="src_2executor_2strand_8cpp_source.html">strand.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="simple_8cpp_source.html#l00176">TEST()</a>.</p>

</div>
</div>
<a id="a3a3348b06a8925f35eb031e9563b1980" name="a3a3348b06a8925f35eb031e9563b1980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3348b06a8925f35eb031e9563b1980">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a>&#160;</td>
          <td class="paramname"><em>acquire</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a>&#160;</td>
          <td class="paramname"><em>release</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00366">366</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="a58431cd89c902b17a1f386e2be4f4d33" name="a58431cd89c902b17a1f386e2be4f4d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58431cd89c902b17a1f386e2be4f4d33">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00358">358</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="a0ba22a625dc73cea7f6310d6e6147aa3" name="a0ba22a625dc73cea7f6310d6e6147aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba22a625dc73cea7f6310d6e6147aa3">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00362">362</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="a6470522549981a792f7a073772ff9c57" name="a6470522549981a792f7a073772ff9c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6470522549981a792f7a073772ff9c57">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cache</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00351">351</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="abd02a3297ea3c5b6de6144c3b993d6f6" name="abd02a3297ea3c5b6de6144c3b993d6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd02a3297ea3c5b6de6144c3b993d6f6">&#9670;&nbsp;</a></span>MakeThreadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ab039debaa8307cdefe0c03481b1bf3da">IThreadPoolPtr</a> yaclib::MakeThreadPool </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>threads</em> = <code>std::thread::hardware_concurrency()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>tf</em> = <code><a class="el" href="namespaceyaclib.html#a6470522549981a792f7a073772ff9c57">MakeThreadFactory</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new ThreadPool object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threads</td><td>the number of threads to create for this ThreadPool </td></tr>
    <tr><td class="paramname">tf</td><td>thread factory to use for thread creation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>intrusive pointer to the new ThreadPool </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="simple_8cpp-example.html#a2">simple.cpp</a>, <a class="el" href="strand_8cpp-example.html#a1">strand.cpp</a>, <a class="el" href="thread_pool_8cpp-example.html#a1">thread_pool.cpp</a>, <a class="el" href="when_all_8cpp-example.html#a2">when_all.cpp</a>, and <a class="el" href="when_any_8cpp-example.html#a2">when_any.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2executor_2thread__pool_8cpp_source.html#l00152">152</a> of file <a class="el" href="src_2executor_2thread__pool_8cpp_source.html">thread_pool.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="simple_8cpp_source.html#l00039">TEST()</a>.</p>

</div>
</div>
<a id="ade53700d8fafbc716f9ff592aafbfcfa" name="ade53700d8fafbc716f9ff592aafbfcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade53700d8fafbc716f9ff592aafbfcfa">&#9670;&nbsp;</a></span>On()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1detail_1_1OnAwaiter.html">detail::OnAwaiter</a> yaclib::On </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO(mkornaukhov03) Add doxygen docs. </p>

<p class="definition">Definition at line <a class="el" href="on_8cpp_source.html#l00005">5</a> of file <a class="el" href="on_8cpp_source.html">on.cpp</a>.</p>

</div>
</div>
<a id="ab205ab99a80599cf567522997ba91b7b" name="ab205ab99a80599cf567522997ba91b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab205ab99a80599cf567522997ba91b7b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00069">69</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a6db9bf2206ad479e4672445453581c4a" name="a6db9bf2206ad479e4672445453581c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db9bf2206ad479e4672445453581c4a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00104">104</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="ad623d6b5af5166e2129c5e7c524ac7a8" name="ad623d6b5af5166e2129c5e7c524ac7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad623d6b5af5166e2129c5e7c524ac7a8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00079">79</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="ab4f85de6a478cf2b7036bbaf9b7f5243" name="ab4f85de6a478cf2b7036bbaf9b7f5243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f85de6a478cf2b7036bbaf9b7f5243">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00109">109</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="aa3e502d06dc99e7d95a4b94cf92c0e7b" name="aa3e502d06dc99e7d95a4b94cf92c0e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e502d06dc99e7d95a4b94cf92c0e7b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator!= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00089">89</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a32c5d80129106db68da58a29eb4c96fa" name="a32c5d80129106db68da58a29eb4c96fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c5d80129106db68da58a29eb4c96fa">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00114">114</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a7f58c88424862c7970f5e34368691501" name="a7f58c88424862c7970f5e34368691501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f58c88424862c7970f5e34368691501">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00064">64</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

<p class="reference">References <a class="el" href="intrusive__ptr__impl_8hpp_source.html#l00084">yaclib::IntrusivePtr&lt; T &gt;::Get()</a>.</p>

</div>
</div>
<a id="aff6c964d5e75d8d4f77e77367eda447f" name="aff6c964d5e75d8d4f77e77367eda447f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6c964d5e75d8d4f77e77367eda447f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00094">94</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="aadf5c2b342ea0d8dcc08d36a688e4002" name="aadf5c2b342ea0d8dcc08d36a688e4002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf5c2b342ea0d8dcc08d36a688e4002">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00074">74</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a7e76ea36acc0b15ff59f471dde2f1bf6" name="a7e76ea36acc0b15ff59f471dde2f1bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e76ea36acc0b15ff59f471dde2f1bf6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00099">99</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a06a93f75dbd32dff52a60d524c1a96db" name="a06a93f75dbd32dff52a60d524c1a96db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a93f75dbd32dff52a60d524c1a96db">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator== </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00084">84</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a910661586b10c7244825a8f94e188500" name="a910661586b10c7244825a8f94e188500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910661586b10c7244825a8f94e188500">&#9670;&nbsp;</a></span>Run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E  = StopError, typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::Run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute Callable func on executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>executor to be used to execute f and saved as callback executor for return <a class="el" href="classyaclib_1_1Future.html">Future</a> </td></tr>
    <tr><td class="paramname">f</td><td>func to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classyaclib_1_1FutureOn.html">FutureOn</a> corresponding f return value </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="simple_8cpp-example.html#a3">simple.cpp</a>, <a class="el" href="when_all_8cpp-example.html#a3">when_all.cpp</a>, and <a class="el" href="when_any_8cpp-example.html#a3">when_any.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8hpp_source.html#l00019">19</a> of file <a class="el" href="run_8hpp_source.html">run.hpp</a>.</p>

<p class="reference">References <a class="el" href="classyaclib_1_1IExecutor.html#a1ee075b04795dcfc0632260f6b5adfc1a0125cf5f3ca38b312ca5d3b511c45a13">yaclib::IExecutor::Inline</a>, <a class="el" href="classyaclib_1_1IExecutor.html#aabbcdb568aa92425c2d4b15f7a3932ff">yaclib::IExecutor::Submit()</a>, <a class="el" href="classyaclib_1_1IExecutor.html#ad4e7a10fd641ca5fcf91d2aeb96da822">yaclib::IExecutor::Tag()</a>, and <a class="el" href="log_8hpp_source.html#l00079">YACLIB_INFO</a>.</p>

<p class="reference">Referenced by <a class="el" href="simple_8cpp_source.html#l00122">CalculatorService::Double()</a>, <a class="el" href="simple_8cpp_source.html#l00116">CalculatorService::Increment()</a>, and <a class="el" href="simple_8cpp_source.html#l00039">TEST()</a>.</p>

</div>
</div>
<a id="ad7a1d3907ba9fca05451fca30c8d9b96" name="ad7a1d3907ba9fca05451fca30c8d9b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a1d3907ba9fca05451fca30c8d9b96">&#9670;&nbsp;</a></span>SetCurrentThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::SetCurrentThreadPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp;&#160;</td>
          <td class="paramname"><em>executor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d7204a0d02995092530f470272dd603" name="a0d7204a0d02995092530f470272dd603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7204a0d02995092530f470272dd603">&#9670;&nbsp;</a></span>SetFaultFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::SetFaultFrequency </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets frequency with which fault will be injected. </p>
<p >Default is 16. </p>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00006">6</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">References <a class="el" href="injector_8cpp_source.html#l00039">yaclib::detail::Injector::SetFrequency()</a>.</p>

</div>
</div>
<a id="a78212c27ad6642817def05396421867b" name="a78212c27ad6642817def05396421867b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78212c27ad6642817def05396421867b">&#9670;&nbsp;</a></span>SetFaultSleepTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::SetFaultSleepTime </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets sleep time if sleep is used instead of yield for interrupting thread execution for fault injection. </p>
<p >Default is 200 </p>

<p class="definition">Definition at line <a class="el" href="config_8cpp_source.html#l00010">10</a> of file <a class="el" href="config_8cpp_source.html">config.cpp</a>.</p>

<p class="reference">References <a class="el" href="injector_8cpp_source.html#l00043">yaclib::detail::Injector::SetSleepTime()</a>.</p>

</div>
</div>
<a id="a1c0acaa9b89820432d210ddcc71cb42e" name="a1c0acaa9b89820432d210ddcc71cb42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0acaa9b89820432d210ddcc71cb42e">&#9670;&nbsp;</a></span>Submit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::Submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &amp;&#160;</td>
          <td class="paramname"><em>executor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit given func for details. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceyaclib.html#a1c0acaa9b89820432d210ddcc71cb42e" title="Submit given func for details.">Submit</a></dd></dl>
<p>This method creates <a class="el" href="classyaclib_1_1Job.html" title="Callable that can be executed in an IExecutor.">Job</a> with one allocation and call Submit(Job) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>func to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="strand_8cpp-example.html#a3">strand.cpp</a>, and <a class="el" href="thread_pool_8cpp-example.html#a2">thread_pool.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="submit_8hpp_source.html#l00017">17</a> of file <a class="el" href="submit_8hpp_source.html">submit.hpp</a>.</p>

<p class="reference">References <a class="el" href="unique__job_8hpp_source.html#l00033">yaclib::detail::MakeUniqueJob()</a>, and <a class="el" href="classyaclib_1_1IExecutor.html#aabbcdb568aa92425c2d4b15f7a3932ff">yaclib::IExecutor::Submit()</a>.</p>

</div>
</div>
<a id="ae5438743a6e37c56005375a161371077" name="ae5438743a6e37c56005375a161371077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5438743a6e37c56005375a161371077">&#9670;&nbsp;</a></span>Wait() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::DefaultEvent, typename... V, typename... E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">YACLIB_INLINE void yaclib::Wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;...&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until Ready becomes true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>one or more futures to wait </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wait_8hpp_source.html#l00018">18</a> of file <a class="el" href="wait_8hpp_source.html">wait.hpp</a>.</p>

<p class="reference">References <a class="el" href="future__impl_8hpp_source.html#l00103">yaclib::FutureBase&lt; V, E &gt;::GetCore()</a>.</p>

</div>
</div>
<a id="aac43d7da2dbbb9a78471db09f0763c58" name="aac43d7da2dbbb9a78471db09f0763c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac43d7da2dbbb9a78471db09f0763c58">&#9670;&nbsp;</a></span>Wait() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::DefaultEvent, typename It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">YACLIB_INLINE std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#a94898f412ae94b871897f8e36f8e3dfd">is_future_base_v</a>&lt; It &gt;, void &gt; yaclib::Wait </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until Ready becomes true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to futures to wait </td></tr>
    <tr><td class="paramname">end</td><td>iterator to futures to wait </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wait_8hpp_source.html#l00029">29</a> of file <a class="el" href="wait_8hpp_source.html">wait.hpp</a>.</p>

</div>
</div>
<a id="a23210d29cc6c824906f9462f648726ed" name="a23210d29cc6c824906f9462f648726ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23210d29cc6c824906f9462f648726ed">&#9670;&nbsp;</a></span>Wait() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::DefaultEvent, typename It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">YACLIB_INLINE void yaclib::Wait </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until Ready becomes true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to futures to wait </td></tr>
    <tr><td class="paramname">count</td><td>of futures to wait </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wait_8hpp_source.html#l00042">42</a> of file <a class="el" href="wait_8hpp_source.html">wait.hpp</a>.</p>

</div>
</div>
<a id="aaf08f280db93b1118870ab362bcde335" name="aaf08f280db93b1118870ab362bcde335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf08f280db93b1118870ab362bcde335">&#9670;&nbsp;</a></span>WaitFor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename... V, typename... E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">YACLIB_INLINE bool yaclib::WaitFor </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;...&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the specified timeout duration has elapsed or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than timeout_duration due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_duration</td><td>maximum duration to block for </td></tr>
    <tr><td class="paramname">fs</td><td>futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__for_8hpp_source.html#l00023">23</a> of file <a class="el" href="wait__for_8hpp_source.html">wait_for.hpp</a>.</p>

<p class="reference">References <a class="el" href="future__impl_8hpp_source.html#l00103">yaclib::FutureBase&lt; V, E &gt;::GetCore()</a>.</p>

</div>
</div>
<a id="a7ee6378d67d9d7b8e141cd4fd2bea401" name="a7ee6378d67d9d7b8e141cd4fd2bea401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee6378d67d9d7b8e141cd4fd2bea401">&#9670;&nbsp;</a></span>WaitFor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">YACLIB_INLINE std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#a94898f412ae94b871897f8e36f8e3dfd">is_future_base_v</a>&lt; Iterator &gt;, bool &gt; yaclib::WaitFor </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the specified timeout duration has elapsed or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than timeout_duration due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_duration</td><td>maximum duration to block for </td></tr>
    <tr><td class="paramname">begin</td><td>iterator to futures to wait </td></tr>
    <tr><td class="paramname">end</td><td>iterator to futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__for_8hpp_source.html#l00038">38</a> of file <a class="el" href="wait__for_8hpp_source.html">wait_for.hpp</a>.</p>

</div>
</div>
<a id="a796e0128328cc5d7112b77af2f6b7c53" name="a796e0128328cc5d7112b77af2f6b7c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796e0128328cc5d7112b77af2f6b7c53">&#9670;&nbsp;</a></span>WaitFor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">YACLIB_INLINE bool yaclib::WaitFor </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the specified timeout duration has elapsed or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than timeout_duration due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_duration</td><td>maximum duration to block for </td></tr>
    <tr><td class="paramname">begin</td><td>iterator to futures to wait </td></tr>
    <tr><td class="paramname">count</td><td>of futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__for_8hpp_source.html#l00056">56</a> of file <a class="el" href="wait__for_8hpp_source.html">wait_for.hpp</a>.</p>

</div>
</div>
<a id="ae86c80b56edf9e77a4600f4c4f34d82e" name="ae86c80b56edf9e77a4600f4c4f34d82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86c80b56edf9e77a4600f4c4f34d82e">&#9670;&nbsp;</a></span>WaitUntil() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename... V, typename... E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">YACLIB_INLINE bool yaclib::WaitUntil </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;...&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until specified time has been reached or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than until after timeout_time has been reached due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>maximum time point to block until </td></tr>
    <tr><td class="paramname">fs</td><td>futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__until_8hpp_source.html#l00023">23</a> of file <a class="el" href="wait__until_8hpp_source.html">wait_until.hpp</a>.</p>

<p class="reference">References <a class="el" href="future__impl_8hpp_source.html#l00103">yaclib::FutureBase&lt; V, E &gt;::GetCore()</a>.</p>

</div>
</div>
<a id="ad58361dfec531ba37119a5b2ae433c80" name="ad58361dfec531ba37119a5b2ae433c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58361dfec531ba37119a5b2ae433c80">&#9670;&nbsp;</a></span>WaitUntil() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">YACLIB_INLINE std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#a94898f412ae94b871897f8e36f8e3dfd">is_future_base_v</a>&lt; Iterator &gt;, bool &gt; yaclib::WaitUntil </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until specified time has been reached or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than until after timeout_time has been reached due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>maximum time point to block until </td></tr>
    <tr><td class="paramname">begin</td><td>iterator to futures to wait </td></tr>
    <tr><td class="paramname">end</td><td>iterator to futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__until_8hpp_source.html#l00039">39</a> of file <a class="el" href="wait__until_8hpp_source.html">wait_until.hpp</a>.</p>

</div>
</div>
<a id="aab43938dc6b5f4e2366693fc724688dd" name="aab43938dc6b5f4e2366693fc724688dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab43938dc6b5f4e2366693fc724688dd">&#9670;&nbsp;</a></span>WaitUntil() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">YACLIB_INLINE bool yaclib::WaitUntil </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until specified time has been reached or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than until after timeout_time has been reached due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>maximum time point to block until </td></tr>
    <tr><td class="paramname">begin</td><td>iterator to futures to wait </td></tr>
    <tr><td class="paramname">count</td><td>of futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__until_8hpp_source.html#l00058">58</a> of file <a class="el" href="wait__until_8hpp_source.html">wait_until.hpp</a>.</p>

</div>
</div>
<a id="ab783f07f4f6c76320de23d0dd0b1da79" name="ab783f07f4f6c76320de23d0dd0b1da79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab783f07f4f6c76320de23d0dd0b1da79">&#9670;&nbsp;</a></span>WhenAll() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::FirstFail, typename E , typename... V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;&amp;...&#160;</td>
          <td class="paramname"><em>futures</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>type of value all passed futures </td></tr>
    <tr><td class="paramname">E</td><td>type of error all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">futures</td><td>two or more futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;std::array&lt;T&gt;&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__all_8hpp_source.html#l00060">60</a> of file <a class="el" href="when__all_8hpp_source.html">when_all.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600ba1a5d257dfef0fee3c8b56cdcc2de854b">FirstFail</a>, and <a class="el" href="when__impl_8hpp_source.html#l00011">yaclib::detail::WhenImpl()</a>.</p>

</div>
</div>
<a id="a4e203f5b4fa643a6e918dc56cfeb5cc8" name="a4e203f5b4fa643a6e918dc56cfeb5cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e203f5b4fa643a6e918dc56cfeb5cc8">&#9670;&nbsp;</a></span>WhenAll() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::FirstFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">YACLIB_INLINE auto yaclib::WhenAll </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,end</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a>&lt;std::vector&lt;future_value_t&lt;T&gt;&gt;, future_error_t&lt;T&gt;&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__all_8hpp_source.html#l00043">43</a> of file <a class="el" href="when__all_8hpp_source.html">when_all.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600ba1a5d257dfef0fee3c8b56cdcc2de854b">FirstFail</a>, and <a class="el" href="when__all_8hpp_source.html#l00025">WhenAll()</a>.</p>

</div>
</div>
<a id="a049387f05e22db54fadbdac6edfc4218" name="a049387f05e22db54fadbdac6edfc4218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049387f05e22db54fadbdac6edfc4218">&#9670;&nbsp;</a></span>WhenAll() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::FirstFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAll </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,count</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a>&lt;std::vector&lt;future_value_t&lt;T&gt;&gt;, future_error_t&lt;T&gt;&gt; </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="when_all_8cpp-example.html#a1">when_all.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="when__all_8hpp_source.html#l00025">25</a> of file <a class="el" href="when__all_8hpp_source.html">when_all.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600ba1a5d257dfef0fee3c8b56cdcc2de854b">FirstFail</a>, <a class="el" href="when__impl_8hpp_source.html#l00011">yaclib::detail::WhenImpl()</a>, and <a class="el" href="log_8hpp_source.html#l00079">YACLIB_INFO</a>.</p>

<p class="reference">Referenced by <a class="el" href="when__all_8hpp_source.html#l00043">WhenAll()</a>.</p>

</div>
</div>
<a id="abddea8e34f0fc25462c13775709fc6fe" name="abddea8e34f0fc25462c13775709fc6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abddea8e34f0fc25462c13775709fc6fe">&#9670;&nbsp;</a></span>WhenAny() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::LastFail, typename E , typename... V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1FutureBase.html">FutureBase</a>&lt; V, E &gt; &amp;&amp;...&#160;</td>
          <td class="paramname"><em>futures</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>policy WhenAny errors </td></tr>
    <tr><td class="paramname">V</td><td>type of value all passed futures </td></tr>
    <tr><td class="paramname">E</td><td>type of error all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">futures</td><td>two or more futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__any_8hpp_source.html#l00069">69</a> of file <a class="el" href="when__any_8hpp_source.html">when_any.hpp</a>.</p>

<p class="reference">References <a class="el" href="when__impl_8hpp_source.html#l00011">yaclib::detail::WhenImpl()</a>.</p>

</div>
</div>
<a id="a68fa2a377ea08ee84f27e8ef086b90db" name="a68fa2a377ea08ee84f27e8ef086b90db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fa2a377ea08ee84f27e8ef086b90db">&#9670;&nbsp;</a></span>WhenAny() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::LastFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">YACLIB_INLINE auto yaclib::WhenAny </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>policy WhenAny errors </td></tr>
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,end</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__any_8hpp_source.html#l00052">52</a> of file <a class="el" href="when__any_8hpp_source.html">when_any.hpp</a>.</p>

</div>
</div>
<a id="acbcdf1285386bdb56057aca0a41fd124" name="acbcdf1285386bdb56057aca0a41fd124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcdf1285386bdb56057aca0a41fd124">&#9670;&nbsp;</a></span>WhenAny() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a301c7b0024b604dfa0baff5e62df600b">WhenPolicy</a> P = WhenPolicy::LastFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAny </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>policy WhenAny errors </td></tr>
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,count</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="when_any_8cpp-example.html#a1">when_any.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="when__any_8hpp_source.html#l00026">26</a> of file <a class="el" href="when__any_8hpp_source.html">when_any.hpp</a>.</p>

<p class="reference">References <a class="el" href="when__any__impl_8hpp_source.html#l00121">yaclib::detail::AnyCombinator&lt; V, E, P &gt;::Make()</a>, <a class="el" href="when__impl_8hpp_source.html#l00011">yaclib::detail::WhenImpl()</a>, and <a class="el" href="log_8hpp_source.html#l00079">YACLIB_INFO</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a94898f412ae94b871897f8e36f8e3dfd" name="a94898f412ae94b871897f8e36f8e3dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94898f412ae94b871897f8e36f8e3dfd">&#9670;&nbsp;</a></span>is_future_base_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool yaclib::is_future_base_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code hl_struct" href="structyaclib_1_1detail_1_1IsInstantiationOf.html">detail::IsInstantiationOf&lt;FutureBase, T&gt;::Value</a> ||  </div>
<div class="line">                                         <a class="code hl_struct" href="structyaclib_1_1detail_1_1IsInstantiationOf.html">detail::IsInstantiationOf&lt;Future, T&gt;::Value</a> ||      </div>
<div class="line">                                         <a class="code hl_struct" href="structyaclib_1_1detail_1_1IsInstantiationOf.html">detail::IsInstantiationOf&lt;FutureOn, T&gt;::Value</a></div>
<div class="ttc" id="astructyaclib_1_1detail_1_1IsInstantiationOf_html"><div class="ttname"><a href="structyaclib_1_1detail_1_1IsInstantiationOf.html">yaclib::detail::IsInstantiationOf</a></div><div class="ttdef"><b>Definition:</b> <a href="type__traits__impl_8hpp_source.html#l00038">type_traits_impl.hpp:38</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00030">30</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a3cc59594eb77f82b357ffd894486c506" name="a3cc59594eb77f82b357ffd894486c506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc59594eb77f82b357ffd894486c506">&#9670;&nbsp;</a></span>is_invocable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename... Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool yaclib::is_invocable_v = <a class="el" href="structyaclib_1_1detail_1_1IsInvocable.html">detail::IsInvocable</a>&lt;Func, Arg...&gt;::Value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00015">15</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a2ce1ff71818739a9a00c65a185cf64ff" name="a2ce1ff71818739a9a00c65a185cf64ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce1ff71818739a9a00c65a185cf64ff">&#9670;&nbsp;</a></span>is_result_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool yaclib::is_result_v = <a class="el" href="structyaclib_1_1detail_1_1IsInstantiationOf.html">detail::IsInstantiationOf</a>&lt;<a class="el" href="classyaclib_1_1Result.html">Result</a>, T&gt;::Value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00021">21</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceyaclib.html">yaclib</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
<script type="text/javascript">
  $(document).ready(function(){
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
  })
</script>
</body>
</html>
